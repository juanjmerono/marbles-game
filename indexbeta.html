<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulación: La mesa se vacía — Canicas (Avanzado)</title>
  <style>
    body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;max-width:1100px;margin:18px auto;padding:18px;color:#111}
    h1{font-size:20px;margin:0 0 6px}
    .controls{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-bottom:12px}
    label{display:block;font-weight:600;margin-top:8px}
    input, select, button{font-size:14px;padding:6px 8px;margin-top:6px;width:100%}
    .panel{border:1px solid #eee;padding:12px;border-radius:8px;background:#fafafa}
    .flex{display:flex;gap:12px}
    .col{flex:1}
    canvas{max-width:100%;height:240px}
    table{border-collapse:collapse;width:100%;margin-top:8px}
    th,td{padding:6px;border:1px solid #eee;text-align:center}
    .log{height:160px;overflow:auto;border:1px solid #eee;padding:8px;background:#fff;margin-top:8px}
    .teamsViz{display:flex;flex-wrap:wrap;gap:6px}
    .team{padding:6px;border-radius:6px;background:#f0f7ff;border:1px solid #cfe3ff}
  </style>
  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>Simulación — Juego "La mesa se vacía" (versión avanzada)</h1>
  <p class="small">Interfaz para experimentar con parámetros, ejecutar múltiples simulaciones y visualizar una ejecución paso a paso con animación, histogramas, evolución y visualización de equipos por ronda. Usa el panel para configurar y elige "Paso a paso" para ver la animación.</p>

  <div class="controls">
    <div class="panel">
      <label>Número de jugadores (N)</label>
      <input id="numPlayers" type="number" value="12" min="2" max="200">

      <label>N.º colores iniciales</label>
      <input id="numColors" type="number" value="6" min="2" max="6">

      <label>Canicas por color (por defecto 14)</label>
      <input id="perColor" type="number" value="14" min="1" max="500">

      <label>Máx canicas por jugador al inicio (0-3)</label>
      <input id="maxInitial" type="number" value="3" min="0" max="10">
    </div>

    <div class="panel">
      <label>Número de rondas tope (≤ nº colores)</label>
      <input id="maxRounds" type="number" value="6" min="1" max="6">

      <label>Simulaciones (batch)</label>
      <input id="runs" type="number" value="200" min="1" max="2000">

      <label>Estrategia de agrupamiento</label>
      <select id="strategy">
        <option value="greedy">Greedy (rápido)</option>
        <option value="greedy-size">Greedy (favorece equipos pequeños)</option>
        <option value="random">Aleatorio</option>
      </select>
    </div>

    <div class="panel">
      <label>Criterio eliminación de color</label>
      <select id="colorCriterion">
        <option value="die">Dado (aleatorio por ronda)</option>
        <option value="organizer">Organizador (elige manualmente)</option>
        <option value="least">Color con menos canicas restantes</option>
        <option value="most">Color con más canicas restantes</option>
        <option value="random">Aleatorio</option>
      </select>

      <label>Modo de ejecución</label>
      <select id="mode">
        <option value="batch">Batch (múltiples simulaciones)</option>
        <option value="single">Una partida (rápida)</option>
        <option value="step">Paso a paso (animación)</option>
      </select>

      <label>&nbsp;</label>
      <button id="runBtn">Ejecutar</button>
      <button id="stopBtn">Parar animación</button>
    </div>
  </div>

  <div class="flex">
    <div class="col panel">
      <h3>Resumen</h3>
      <div id="summary">—</div>
      <div class="log" id="logbox">Logs de la ejecución aparecerán aquí.</div>
    </div>

    <div class="col panel">
      <h3>Visualizaciones</h3>
      <canvas id="chartHist"></canvas>
      <canvas id="chartEvo" style="margin-top:12px"></canvas>
    </div>
  </div>

  <div class="panel" style="margin-top:12px">
    <h3>Detalle de la partida (equipos por ronda)</h3>
    <div id="roundControls" style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
      <label>Ronda:</label>
      <input id="roundSlider" type="range" min="0" max="5" value="0" style="flex:1">
      <div id="roundLabel">0</div>
      <button id="prevRound">«</button>
      <button id="nextRound">»</button>
    </div>
    <div id="teamsContainer" class="teamsViz"></div>
  </div>

<script>
// --- Motor de simulación (adaptado y extendido)
function randInt(n){ return Math.floor(Math.random()*n); }
function rollDie(){ return randInt(6)+1; }

function initialDeal(N, perColor, maxInitial, numColors){
  const colors = Array.from({length:numColors},(_,i)=>({id:i, total:perColor}));
  const players = [];
  for(let i=0;i<N;i++){
    const take = Math.floor(Math.random()*(maxInitial+1));
    const holdings = Array(numColors).fill(0);
    let remainingTake = take;
    const colorIdxs = [...Array(numColors).keys()];
    while(remainingTake>0){
      const shuffled = colorIdxs.sort(()=>Math.random()-0.5);
      let assigned=false;
      for(const c of shuffled){
        if(colors[c].total>0){ holdings[c]++; colors[c].total--; remainingTake--; assigned=true; break; }
      }
      if(!assigned) break;
    }
    players.push({id:i, holdings});
  }
  return {players, colors};
}

function totalPlayer(p){ return p.holdings.reduce((a,b)=>a+b,0); }

// Forma equipos heurísticos
function formTeams(players, T, strategy, numColors){
  const pool = players.map(p=>({id:p.id, holdings:p.holdings.slice(), total: totalPlayer(p)}));
  const included = new Set();
  const teams = [];
  // singles
  const singles = pool.filter(p=>p.total>=T).sort((a,b)=>a.total-b.total);
  for(const s of singles){ if(!included.has(s.id)){ teams.push({members:[s.id], contributed:T}); let need=T; for(let c=0;c<numColors && need>0;c++){ const give=Math.min(s.holdings[c],need); s.holdings[c]-=give; need-=give; s.total-=give; } included.add(s.id); } }
  const K = 6;
  function candidates(){ return pool.filter(p=>!included.has(p.id) && p.total>0).sort((a,b)=> (strategy==='greedy-size' ? a.total-b.total : b.total-a.total)); }
  while(true){
    const cand = candidates(); if(cand.length===0) break;
    let found=false;
    for(let size=2; size<=Math.min(K,cand.length); size++){
      const attempts = 300;
      for(let a=0;a<attempts;a++){
        const subset = [];
        const idxs = [...Array(cand.length).keys()].sort(()=>Math.random()-0.5).slice(0,size);
        let sum = 0;
        for(const idx of idxs){ sum += cand[idx].total; subset.push(cand[idx]); }
        if(sum>=T){
          let need=T;
          for(const member of subset){ for(let c=0;c<numColors && need>0;c++){ const give=Math.min(member.holdings[c], need); member.holdings[c]-=give; need-=give; member.total-=give; } }
          const memberIds = subset.map(s=>s.id);
          teams.push({members:memberIds, contributed:T}); memberIds.forEach(id=>included.add(id)); found=true; break;
        }
      }
      if(found) break;
    }
    if(!found) break;
  }
  return {teams, included};
}

// Ejecuta una única partida (y retorna el detalle por ronda)
function runSingle(settings){
  const {N, perColor, maxInitial, maxRounds, strategy, colorCriterion, mode, numColors} = settings;
  const deal = initialDeal(N, perColor, maxInitial, numColors);
  let players = deal.players.map(p=>({id:p.id, holdings:p.holdings.slice()}));

  // Active color list (ensures each color removed at most once)
  let activeColors = [...Array(numColors).keys()];
  const record = [];

  // If criterion is "none", we never remove colors and allow up to maxRounds
  const noElimination = (colorCriterion === 'none');

  const rounds = noElimination ? maxRounds : Math.min(maxRounds, activeColors.length);

  for(let r=0; r<rounds; r++){
    const T = rollDie();
    const teamsInfo = formTeams(players, T, strategy, activeColors.length);
    const included = teamsInfo.included;
    const teams = teamsInfo.teams;
    const eliminatedPlayers = players.filter(p=> !included.has(p.id));

    record.push({round:r+1, T, teams, eliminated:eliminatedPlayers.map(p=>p.id), playersState:players.map(p=>({id:p.id, holdings:p.holdings.slice(), total: totalPlayer(p)}))});

    if(eliminatedPlayers.length===0){ return {record, endedBy:'no_elimination'}; }

    players = players.filter(p=> included.has(p.id));

    if(!noElimination){
      // Choose a color from activeColors
      let colorToRemove;
      if(colorCriterion==='die' || colorCriterion==='random'){
        colorToRemove = activeColors[randInt(activeColors.length)];
      } else if(colorCriterion==='organizer'){
        colorToRemove = settings.organizerChoice!==undefined ? settings.organizerChoice : activeColors[randInt(activeColors.length)];
      } else if(colorCriterion==='least' || colorCriterion==='most'){
        const totals = activeColors.map(c=>({c,total:players.reduce((sum,p)=>sum+p.holdings[c],0)}));
        if(colorCriterion==='least'){ colorToRemove = totals.reduce((a,b)=>a.total<b.total?a:b).c; }
        else { colorToRemove = totals.reduce((a,b)=>a.total>b.total?a:b).c; }
      }

      // Remove selected color from all players
      for(const p of players){ p.holdings[colorToRemove]=0; }

      // Remove color from active list
      activeColors = activeColors.filter(c=>c!==colorToRemove);

      record[record.length-1].colorRemoved = colorToRemove;

      // If no colors left, stop early
      if(activeColors.length===0){ return {record, endedBy:'no_colors_left'}; }
    }
  }

  return {record, endedBy:'round_limit'};
}

// Batch runner
function runBatch(settings, runs){
  const survivors = [];
  const allRecords = [];
  for(let i=0;i<runs;i++){
    const res = runSingle(settings);
    const last = res.record[res.record.length-1];
    const survivorsCount = last ? (last.playersState ? last.playersState.filter(p=>p.total>0).length : 0) : 0;
    survivors.push(res.record[res.record.length-1] ? res.record[res.record.length-1].playersState.length : 0);
    allRecords.push(res);
  }
  return {survivors, allRecords};
}

// --- UI / Charts
let histChart=null, evoChart=null;
function createHist(data){
  const ctx = document.getElementById('chartHist').getContext('2d');
  const counts = {};
  data.forEach(c=> counts[c]= (counts[c]||0)+1 );
  const labels = Object.keys(counts).sort((a,b)=>a-b);
  const vals = labels.map(l=>counts[l]);
  if(histChart) histChart.destroy();
  histChart = new Chart(ctx, {type:'bar', data:{labels, datasets:[{label:'Frecuencia', data:vals}]}, options:{responsive:true, plugins:{legend:{display:false}}}});
}

function createEvo(record){
  // plot total canicas por jugador (avg) y nº supervivientes por ronda
  const ctx = document.getElementById('chartEvo').getContext('2d');
  const labels = record.map(r=>`R${r.round}`);
  const avgCanicas = record.map(r=>{
    const totals = r.playersState.map(p=>p.total); return (totals.reduce((a,b)=>a+b,0)/Math.max(1,totals.length)).toFixed(2);
  });
  const survivors = record.map(r=>r.playersState.length);
  if(evoChart) evoChart.destroy();
  evoChart = new Chart(ctx, {type:'line', data:{labels, datasets:[{label:'Canicas promedio por jugador', data:avgCanicas, tension:0.4},{label:'Jugadores en juego', data:survivors, tension:0.4}]}, options:{responsive:true}});
}

function renderRound(record, idx){
  const r = record[idx];
  document.getElementById('roundLabel').textContent = r ? `Ronda ${r.round}` : '0';
  const container = document.getElementById('teamsContainer'); container.innerHTML='';
  if(!r) return;
  const title = document.createElement('div'); title.textContent = `T=${r.T} — Color eliminado al final: ${r.colorRemoved!==undefined?('C'+(r.colorRemoved+1)):'(por decidir)'}`;
  container.appendChild(title);
  // teams
  r.teams.forEach((t,i)=>{
    const el = document.createElement('div'); el.className='team'; el.textContent = `Equipo ${i+1}: miembros ${t.members.join(', ')} (contrib ${t.contributed})`; container.appendChild(el);
  });
  // eliminated
  const elim = document.createElement('div'); elim.style.marginTop='8px'; elim.textContent = `Eliminados: ${r.eliminated.length>0 ? r.eliminated.join(', ') : 'ninguno'}`; container.appendChild(elim);
}

// Controls
const runBtn = document.getElementById('runBtn');
const stopBtn = document.getElementById('stopBtn');
let animationTimer=null;
let currentPlayRecord=null;

runBtn.addEventListener('click', ()=>{
  const N = parseInt(document.getElementById('numPlayers').value,10);
  const numColors = parseInt(document.getElementById('numColors').value,10);
  const perColor = parseInt(document.getElementById('perColor').value,10);
  const maxInitial = parseInt(document.getElementById('maxInitial').value,10);
  const maxRounds = Math.min(parseInt(document.getElementById('maxRounds').value,10), numColors);
  const runs = parseInt(document.getElementById('runs').value,10);
  const strategy = document.getElementById('strategy').value;
  const colorCriterion = document.getElementById('colorCriterion').value;
  const mode = document.getElementById('mode').value;
  const settings = {N, perColor, maxInitial, maxRounds, strategy, colorCriterion, mode, numColors};

  document.getElementById('logbox').textContent='Ejecutando...';
  if(mode==='batch'){
    const res = runBatch(settings, runs);
    createHist(res.survivors);
    document.getElementById('summary').innerHTML = `Runs: ${runs} — Media supervivientes: ${(res.survivors.reduce((a,b)=>a+b,0)/res.survivors.length).toFixed(2)}`;
  } else if(mode==='single'){
    const res = runSingle(settings);
    const record = res.record;
    createHist([record[record.length-1].playersState.length]);
    createEvo(record);
    document.getElementById('summary').innerHTML = `Resultado: ${record[record.length-1].playersState.length} jugadores restantes — fin: ${res.endedBy}`;
    // prepare round slider
    setupRecordPlayback(record);
  } else if(mode==='step'){
    const res = runSingle(settings);
    const record = res.record;
    createHist([record[record.length-1].playersState.length]);
    createEvo(record);
    document.getElementById('summary').innerHTML = `Modo paso a paso — Rondas: ${record.length}`;
    setupRecordPlayback(record);
    // autoplay
    let i=0; currentPlayRecord=record;
    animationTimer = setInterval(()=>{ if(i>=record.length){ clearInterval(animationTimer); } else { document.getElementById('roundSlider').value = i; renderRound(record, i); i++; } }, 1000);
  }
});

stopBtn.addEventListener('click', ()=>{ if(animationTimer) clearInterval(animationTimer); });

function setupRecordPlayback(record){
  const slider = document.getElementById('roundSlider'); slider.max = record.length-1; slider.value = 0; renderRound(record,0);
  slider.oninput = ()=>{ renderRound(record, parseInt(slider.value,10)); };
  document.getElementById('prevRound').onclick = ()=>{ slider.value=Math.max(0, parseInt(slider.value,10)-1); slider.oninput(); };
  document.getElementById('nextRound').onclick = ()=>{ slider.value=Math.min(parseInt(slider.max,10), parseInt(slider.value,10)+1); slider.oninput(); };
}

</script>
</body>
</html>
